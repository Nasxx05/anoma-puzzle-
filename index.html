<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anoma Proof of Human Game</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            color: white;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            min-width: 300px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .timer {
            font-size: 24px;
            font-weight: bold;
            color: #e74c3c;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .score {
            font-size: 20px;
            font-weight: bold;
            color: #27ae60;
        }

        .start-button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .start-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .puzzle-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            max-width: 900px;
            width: 100%;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        .puzzle-container.active {
            opacity: 1;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            gap: 2px;
            margin-bottom: 30px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            pointer-events: none;
        }

        .grid.active {
            pointer-events: auto;
        }

        .cell {
            width: 35px;
            height: 35px;
            border: 2px solid #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 4px;
        }

        .cell:hover {
            background: #e8f4fd;
            transform: scale(1.1);
        }

        .cell.selected {
            background: #f39c12;
            color: white;
            border-color: #e67e22;
        }

        .cell.found {
            background: #27ae60;
            color: white;
            border-color: #229954;
        }

        .word-list {
            text-align: center;
            margin-top: 20px;
        }

        .word-count {
            font-size: 18px;
            color: #2c3e50;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .instructions {
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            color: #2c3e50;
            font-weight: 500;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 10% auto;
            padding: 40px;
            border-radius: 20px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            color: white;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease;
        }

        .modal h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .score-display {
            font-size: 1.8em;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
        }

        .play-again-button {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .play-again-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer.warning {
            animation: pulse 1s infinite;
        }

        @media (max-width: 768px) {
            .cell {
                width: 25px;
                height: 25px;
                font-size: 12px;
            }
            .header {
                font-size: 1.5em;
                padding: 15px 25px;
            }
            .modal-content {
                margin: 20% auto;
                padding: 30px 20px;
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        Anoma proof of human game
    </div>

    <div class="game-info">
        <div class="timer" id="timer">‚è±Ô∏è 01:00</div>
        <div class="score" id="score">Score: 0/15</div>
    </div>

    <button class="start-button" id="startButton" onclick="startGame()">
        Start Game
    </button>

    <div class="puzzle-container" id="puzzleContainer">
        <div class="instructions">
            Find hidden words in the grid! Click and drag to select letters.
            <br>Words can be horizontal, vertical, or diagonal in any direction.
        </div>

        <div class="grid" id="grid">
            <!-- Grid will be generated by JavaScript -->
        </div>

        <div class="word-list">
            <div class="word-count" id="wordCount">Find 15 hidden words!</div>
        </div>
    </div>

    <!-- Success Modal -->
    <div id="successModal" class="modal">
        <div class="modal-content">
            <h2>üéâ Congratulations!</h2>
            <div class="score-display" id="finalScore"></div>
            <p id="completionMessage"></p>
            <button class="play-again-button" onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        // 15x15 grid with hidden words
        const grid = [
            ['A', 'N', 'O', 'M', 'A', 'G', 'E', 'A', 'M', 'E', 'R', 'T', 'Y', 'U', 'I'],
            ['B', 'L', 'O', 'C', 'K', 'C', 'H', 'A', 'I', 'N', 'E', 'S', 'D', 'F', 'G'],
            ['O', 'I', 'G', 'A', 'N', 'O', 'P', 'E', 'R', 'E', 'H', 'J', 'K', 'L', 'Q'],
            ['P', 'R', 'I', 'V', 'A', 'C', 'Y', 'N', 'D', 'E', 'U', 'M', 'A', 'N', 'W'],
            ['E', 'N', 'T', 'O', 'K', 'E', 'N', 'A', 'M', 'E', 'R', 'T', 'Y', 'U', 'E'],
            ['R', 'O', 'P', 'D', 'R', 'E', 'N', 'D', 'T', 'E', 'Q', 'W', 'E', 'R', 'R'],
            ['A', 'D', 'E', 'C', 'E', 'N', 'T', 'R', 'A', 'L', 'I', 'Z', 'E', 'D', 'T'],
            ['T', 'E', 'S', 'T', 'H', 'M', 'M', 'A', 'N', 'G', 'H', 'J', 'K', 'L', 'Y'],
            ['I', 'V', 'A', 'L', 'I', 'D', 'A', 'T', 'O', 'R', 'S', 'D', 'F', 'G', 'U'],
            ['O', 'E', 'R', 'I', 'F', 'I', 'C', 'A', 'T', 'I', 'O', 'N', 'A', 'S', 'I'],
            ['N', 'R', 'G', 'O', 'V', 'E', 'R', 'N', 'A', 'N', 'C', 'E', 'Q', 'W', 'O'],
            ['S', 'I', 'Z', 'K', 'P', 'R', 'O', 'T', 'O', 'C', 'O', 'L', 'E', 'R', 'P'],
            ['E', 'F', 'I', 'C', 'A', 'T', 'I', 'O', 'N', 'M', 'N', 'B', 'V', 'C', 'A'],
            ['C', 'Y', 'B', 'E', 'R', 'S', 'E', 'C', 'U', 'R', 'I', 'T', 'Y', 'H', 'S'],
            ['U', 'R', 'I', 'T', 'Y', 'D', 'I', 'G', 'I', 'T', 'A', 'L', 'G', 'H', 'S']
        ];

        const words = [
            'ANOMA', 'BLOCKCHAIN', 'PRIVACY', 'TOKEN', 'DECENTRALIZED',
            'HUMAN', 'GAME', 'VERIFICATION', 'VALIDATOR', 'GOVERNANCE',
            'PROTOCOL', 'SECURITY', 'DIGITAL', 'CYBERSECURITY', 'OPERATION'
        ];

        let gameActive = false;
        let timeLeft = 60;
        let timerInterval;
        let selectedCells = [];
        let foundWords = new Set();
        let isSelecting = false;

        function createGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';

            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = grid[i][j];
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    cell.addEventListener('mousedown', (e) => startSelection(i, j, e));
                    cell.addEventListener('mouseenter', (e) => extendSelection(i, j, e));
                    cell.addEventListener('mouseup', () => endSelection());
                    
                    gridElement.appendChild(cell);
                }
            }

            document.addEventListener('mouseup', endSelection);
        }

        function startSelection(row, col, e) {
            if (!gameActive) return;
            isSelecting = true;
            clearSelection();
            selectCell(row, col);
            e.preventDefault();
        }

        function extendSelection(row, col, e) {
            if (!gameActive || !isSelecting) return;
            
            if (selectedCells.length > 0) {
                const firstCell = selectedCells[0];
                const newSelection = getLinePath(firstCell.row, firstCell.col, row, col);
                
                clearSelection();
                newSelection.forEach(pos => selectCell(pos.row, pos.col));
            }
        }

        function endSelection() {
            if (!gameActive || !isSelecting) return;
            isSelecting = false;
            checkForWord();
        }

        function getLinePath(row1, col1, row2, col2) {
            const path = [];
            const deltaRow = row2 - row1;
            const deltaCol = col2 - col1;
            
            // Check if it's a valid line (horizontal, vertical, or diagonal)
            if (deltaRow !== 0 && deltaCol !== 0 && Math.abs(deltaRow) !== Math.abs(deltaCol)) {
                return [{row: row1, col: col1}]; // Return only first cell if not a valid line
            }
            
            const steps = Math.max(Math.abs(deltaRow), Math.abs(deltaCol));
            const stepRow = steps === 0 ? 0 : deltaRow / steps;
            const stepCol = steps === 0 ? 0 : deltaCol / steps;
            
            for (let i = 0; i <= steps; i++) {
                path.push({
                    row: row1 + Math.round(stepRow * i),
                    col: col1 + Math.round(stepCol * i)
                });
            }
            
            return path;
        }

        function selectCell(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cell && !cell.classList.contains('found')) {
                cell.classList.add('selected');
                selectedCells.push({row, col, letter: grid[row][col]});
            }
        }

        function clearSelection() {
            selectedCells.forEach(cell => {
                const cellElement = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                if (cellElement && !cellElement.classList.contains('found')) {
                    cellElement.classList.remove('selected');
                }
            });
            selectedCells = [];
        }

        function checkForWord() {
            if (selectedCells.length < 3) {
                clearSelection();
                return;
            }

            const selectedWord = selectedCells.map(cell => cell.letter).join('');
            const reversedWord = selectedWord.split('').reverse().join('');

            let wordFound = false;
            words.forEach(word => {
                if ((selectedWord === word || reversedWord === word) && !foundWords.has(word)) {
                    foundWords.add(word);
                    wordFound = true;
                    
                    // Mark cells as found
                    selectedCells.forEach(cell => {
                        const cellElement = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                        cellElement.classList.remove('selected');
                        cellElement.classList.add('found');
                    });
                    
                    updateScore();
                    
                    if (foundWords.size === words.length) {
                        endGame(true);
                    }
                }
            });

            if (!wordFound) {
                clearSelection();
            } else {
                selectedCells = [];
            }
        }

        function startGame() {
            gameActive = true;
            timeLeft = 60;
            foundWords.clear();
            
            document.getElementById('startButton').disabled = true;
            document.getElementById('startButton').textContent = 'Game in Progress...';
            document.getElementById('puzzleContainer').classList.add('active');
            document.getElementById('grid').classList.add('active');
            
            // Clear any previously found cells
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('found', 'selected');
            });
            
            updateScore();
            startTimer();
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimer();
                
                if (timeLeft <= 10) {
                    document.getElementById('timer').classList.add('warning');
                }
                
                if (timeLeft <= 0) {
                    endGame(false);
                }
            }, 1000);
        }

        function updateTimer() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            document.getElementById('timer').textContent = 
                `‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateScore() {
            document.getElementById('score').textContent = `Score: ${foundWords.size}/15`;
        }

        function endGame(completed) {
            gameActive = false;
            clearInterval(timerInterval);
            
            const score = foundWords.size;
            const timeUsed = 60 - timeLeft;
            const bonusPoints = completed ? (timeLeft * 10) : 0;
            const totalScore = (score * 100) + bonusPoints;
            
            document.getElementById('finalScore').innerHTML = `
                Words Found: ${score}/15<br>
                Time Used: ${Math.floor(timeUsed / 60)}:${(timeUsed % 60).toString().padStart(2, '0')}<br>
                ${bonusPoints > 0 ? `Time Bonus: ${bonusPoints} points<br>` : ''}
                Total Score: ${totalScore} points
            `;
            
            let message;
            if (completed) {
                message = "üèÜ Perfect! You found all the words and proved you're human!";
            } else if (score >= 10) {
                message = "üéØ Great job! You found most of the words!";
            } else if (score >= 5) {
                message = "üëç Good effort! Keep practicing to improve your score!";
            } else {
                message = "üí™ Don't give up! Try again to beat your score!";
            }
            
            document.getElementById('completionMessage').textContent = message;
            document.getElementById('successModal').style.display = 'block';
        }

        function resetGame() {
            gameActive = false;
            timeLeft = 60;
            foundWords.clear();
            selectedCells = [];
            clearInterval(timerInterval);
            
            document.getElementById('timer').textContent = '‚è±Ô∏è 01:00';
            document.getElementById('timer').classList.remove('warning');
            document.getElementById('startButton').disabled = false;
            document.getElementById('startButton').textContent = 'Start Game';
            document.getElementById('puzzleContainer').classList.remove('active');
            document.getElementById('grid').classList.remove('active');
            document.getElementById('successModal').style.display = 'none';
            
            // Clear all cell states
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('found', 'selected');
            });
            
            updateScore();
        }

        // Initialize the game
        createGrid();
        updateScore();
    </script>
</body>
</html>